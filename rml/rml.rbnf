import std.common.[Name DoubleQuotedStr Comment Space]


Symbol ::= Name as name| 'var' as sign (Symbol | keyword) as name
           rewrite
               Symbol(*loc(sign if sign else name), name.value)

keyword cast := 'let' 'for' 'yield' 'in' 'match' 'with' 'do' 'fn' 'of' 'var' 'where'

_In ::= 'in'
         when check_indent(_1)


_Yield ::= 'yield'
            when check_indent(_1)

_Do    ::= 'do'
            when check_indent(_1)

_Line ::= '|'
           when check_indent(_1)

_Case ::= Case as ret
          when check_indent(_1)
          rewrite ret

_Arrow ::= '->'
           when check_indent(_1)

_When  :: 'when'
           when check_indent(_1)

Let ::= 'let' as _1
                (Pattern '=' Expr)+ as binds
         _In Stmts as stuff
         rewrite
            pattern_match = tuple(Destruct(*loc(pat), pat, value) for pat, _, value in binds)
            Bind(*loc(_1), pattern_match, stuff)

For ::= 'for' as _1 Pattern as pat _In Expr as collection
         (_Yield | _Do as void)
            Stmts as stuff
         rewrite
            For(*loc(_1), pat, collection, stuff, not void)

Match ::= 'match' as _1 Expr as expr 'with'
           ((_Line Case)+ as seq1 | _Case as h (_Line Case)+ as seq2)
          rewrite
            Match(*loc(_1), expr, seq1[1::2] if seq1 else (h, *seq2[::2]))

Case  ::= (Pattern as _1) as _pat
          [_When  as  _1  Stmts as when_clause]
          [_Arrow Stmts as stuff]
          rewrite
            Case(*loc(pat), pat, stuff, when_clause)

Lambda ::= | 'fn' as _1  ('(' ')'| Pattern+ as args) '->' Stmts as stuff
           | 'fn' as _1  (_Line Case)+ as seq
          rewrite
            Lambda(*loc(_1), args, stuff) if stuff else LambdaCases(*loc(_1), seq[::2])

_ADT ::= ADT as ret
         when check_indent(_1)


TypeSigImp ::=
              | '\'' as _1 Symbol as sym [':' Symbol as refine]
              | '(' (TypeSigImp ('*' TypeSigImp)*) as seq ')'
              | TypeSig as sig
            rewrite
                sig if sig else\
                (TupleType(tuple(seq[::2])) if len(seq) is not 1 else seq[0]) if seq else\
                Undecided(*loc(_1), sym, refine)

TypeSigSeq ::= (TypeSigImp ('*' TypeSigImp)*) as seq
               rewrite
                    TupleType(tuple(seq[::2]))

TypeSig ::= Symbol as name ['of' TypeSigSeq as type_spec]
     rewrite
        TypeSig(*loc(name), name, type_spec)

TypeDef  ::=
    | 'type' as _1 TypeSig as sig '='
       '{'
            (FieldDecl (';' FieldDecl)*) as fields
       '}'
    | 'type' as _1  TypeSig as sig '='
        ((_Line ADT)+ as seq1 | _ADT (_Line ADT)+ as seq2)
    rewrite
        DiscriminateUnionDef(*loc(_1), sig, seq1 if seq1 else seq2) if not fields else\
        RecordDef(*loc(_1), sig, fields)



ADT ::= Symbol as tag [TypeSigSeq as cons]
        rewrite
            ADT(*loc(tag), tag, cons[::2] if cons else None)

Expr ::=
    | Let
    | For
    | Match
    | IfExp
    | BinOpr
    

Pattern ::=
    | ConsPattern
    | ListPattern
    | TuplePattern
    | RecordPattern
    | ADTPattern
    | NamePattern
    | LiteralExpr


PatternPair ::= NamePattern as key '=' Pattern as value
                rewrite
                    PatternPair(*loc(key), key, value)

ConsPattern ::= Pattern as head '::' ListPattern as tail
                rewrite
                    ConsPattern(head, tail)
ListPattern ::= '[' (Pattern (',' Pattern)*) as seq ']'
                 rewrite
                    ListPattern(tuple(seq[::2]))


TuplePattern ::= '(' (Pattern (',' Pattern)*) as seq ')'
                  rewrite
                    TuplePattern(tuple(seq[::2]))

RecordPattern ::= '{' as _1 (PatternPair (',' PatternPair)*) as seq  '}'
                rewrite
                    RecordPattern(*loc(_1), tuple(seq[::2]))


ADTPattern ::= Symbol as sym '(' (Pattern (',' Pattern)*) as seq ')'
                rewrite
                    ADTPattern(*loc(sym), sym, tuple(seq[::2]))


NamePattern ::= Symbol as sym
                rewrite NamePattern(*loc(sym), sym.name)

LiteralExpr ::= Atom as atom
                rewrite LiteralExpr(*loc(atom), atom)



BinOpr ::= UnaryOpr (BinOp UnaryOpr)*

UnaryOpr ::= App | UnaryOp UnaryOpr

App    ::= ConsExpr as _1 (ConstExpr as _1)*

ConsExpr ::= IndexExpr as head ['::' ConsExpr]
            when
                not _1 or check_not_new_line(state, tokens, _1)

IndexExpr ::= AccessorExpr ('.' '[' Expr ']')*

AccessorExpr ::=  AtomExpr ('.' Symbol)*

AtomExpr ::=
        | Symbol
        | Literal
        | Atom

Literal ::=
    | ListLiteral
    | ArrayLiteral
    | TupleLiteral
    | RecordLiteral

ListLiteral::= '[' as _1 [(Expr (',' Expr)*)] as seq ']'
                rewrite
                    ListLiteral(*loc(_1), tuple(seq[::2]))

ArrayLiteral ::= '[|' as _1 [(Expr (',' Expr)*)] as seq '|]'
                 rewrite
                    ArrayLiteral(*loc(_1), tuple(seq[::2]))


TupleLiteral ::= '(' as _1 [(Expr (',' Expr)*) [',']] as seq ')'
                rewrite
                    TupleLiteral(*loc(_1), tuple(seq[::2]))


ExprPair ::= Symbol as key '=' Expr as value
                rewrite
                    ExprPair(*loc(key), key, value)

RecordLiteral ::= '{' as _1 [(ExprPair (',' ExprPair)*)] as seq  '}'
                rewrite
                    RecordLiteral(*loc(_1), tuple(seq[::2]))

Atom ::=
    | Number
    | String
    | Const
    | Lambda

Stmt :=
    | Expr as body
    | TypeDef as body
    | ModuleDef as body
    with
        not _1 or body.colno == _1.colno


Separator ::= ';'
            when check_not_new_line(state, tokens, _1)


Stmts := (Stmt as _1 [Separator])+ as seq
    when
        not _1 or check_indent(state, tokens, _1)
    rewrite
        tuple(seq[::2])

ModuleDef =
    'module' as _ Symbol as mod_name 'where' Stmts as seq
     ModuleDef(*loc(_), mod_name, tuple(seq))
